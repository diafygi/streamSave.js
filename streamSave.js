/*
This allows you to prompt the user to save a file, then the file can be
populated with data dynamically generated by javascript.

Copyright Daniel Roesler. Released under The MIT License

Inspired from https://github.com/jimmywarting/StreamSaver.js
*/

function StreamSave(options) {
    // default options
    this.options = options || {};
    this.options.baseUrl = this.options.baseUrl || location.origin;
    this.options.serviceWorker = this.options.serviceWorker || "./streamSaveServiceWorker.js";

    // trigger prompt to save a file and return a stream to write data to that file
    this.promptSave = async (filename, filesize) => {

        // assign random url and headers for the download
        const url = this.options.baseUrl + "/" + crypto.randomUUID() + "/" + filename;
        const headers = {
            "Content-Type": "application/octet-stream",
            "Content-Disposition": "attachment; attachment; filename=\"" + filename + "\"",
        };
        if (filesize !== undefined) headers['Content-Length'] = filesize;

        // use message channels to trigger a download by loading an iframe
        // with a URL that will be MITM'd by a service worker
        const ts = new TransformStream();
        const stream = ts.readable;
        const channel = new MessageChannel();
        channel.port1.postMessage({ stream, url, headers }, [ stream ]);
        channel.port1.onmessage = evt => {
            const iframe = document.createElement("iframe");
            iframe.hidden = true;
            iframe.src = evt.data.url;
            document.body.appendChild(iframe);
        }

        // register the service worker to listen and MITM download requests
        const swReg = await navigator.serviceWorker.getRegistration(this.options.baseUrl) ||
            await navigator.serviceWorker.register(this.options.serviceWorker, { scope: this.options.baseUrl });
        if (swReg.installing)
            await new Promise((r) => { swReg.installing.onstatechange = e => { if (e.target.state === "activated") r() } });
        swReg.active.postMessage({}, [ channel.port2 ]);

        // return stream that can be pushed data to the download
        return ts.writable.getWriter();
    }
}

